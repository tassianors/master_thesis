%===============================================================================
\section{Controle baseado em dados}
\label{sec:vrft_control_data_based}
%===============================================================================
O projeto de controladores baseados em dados consiste em obter ou estimar os parâmetros de um modelo
baseado nos dados obtidos da planta sob análise. Os dados utilizados para esta
tarefa são usualmente o sinal de entrada e saída do sistema.

Como já foi discutido na seção (\ref{sec:si_project_experiments}) estes dados podem ser obtidos de
diversas formas. Algumas vezes estas informações podem vir da operação normal da planta em malha
fechada com a presença de algum controlador. Situação esta que tem um grande apelo em plantas
industriais, onde a parada do processo, para levantamento de informações, é indesejável e muitas
vezes até inviável. Se existe a possibilidade de parar a planta e aplicar sinais predeterminados,
o projeto de experimentos pode trazer muitas vantagens.

Seja a esperança de um valor $E\left [ \cdot \right ]$ definido por: \cite{ljung}

\begin{equation}
\bar{E}\left [ f(t) \right ]\equiv \lim_{N \to \infty } \frac{1}{N}\sum_{t=1}^{N}E\left [ f(t)
\right]
\label{eq:vrft_db_hope}
\end{equation}

O ruído é um processo quasi-estacionário, que pode ser descrito como $\nu(t)=H_0(z)e(t)$, onde
$e(t)$ é ruído branco com variância $\sigma_e^2$. Ambas funções de transferência, $G_0(z)$ e $H_0(z)$,
são racionais e causais. Assume-se que $H(\infty)=1$, ou seja, a resposta impulsiva do filtro
$H_0(z)$ satisfaz $h(0)=1$. \cite{campestrini}

Na Figura (\ref{fig:vrft_db_control_loop}) é apresentado uma malha de controle onde o controlador
$C(z, \rho) \in \mathcal{C}$ onde $ \mathcal{C}$ é a classe de controladores definida pelo usuário.

\begin{figure}[htbp]
\center
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-1.1092187)(9.868125,1.1292187)
\pscircle[linewidth=0.04,dimen=outer](1.4,-0.08921875){0.2}
\psframe[linewidth=0.04,dimen=outer](4.4,0.31078124)(2.6,-0.48921874)
\psframe[linewidth=0.04,dimen=outer](7.2,0.31078124)(5.6,-0.48921874)
\pscircle[linewidth=0.04,dimen=outer](8.4,-0.08921875){0.2}
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(0.0,-0.08921875)(1.2,-0.08921875)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(1.6,-0.08921875)(2.6,-0.08921875)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(4.4,-0.08921875)(5.6,-0.08921875)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(7.2,-0.08921875)(8.2,-0.08921875)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.4,0.7107813)(8.4,0.11078125)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.6,-0.08921875)(9.8,-0.08921875)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(1.4,-0.28921875)(1.4,-1.0892187)
\psline[linewidth=0.04cm](1.4,-1.0892187)(9.2,-1.0892187)
\psline[linewidth=0.04cm](9.2,-1.0892187)(9.2,-0.08921875)
\usefont{T1}{ptm}{m}{n}
\rput(1.1126562,0.22078125){+}
\usefont{T1}{ptm}{m}{n}
\rput(8.112657,0.22078125){+}
\usefont{T1}{ptm}{m}{n}
\rput(8.112657,-0.37921876){+}
\usefont{T1}{ptm}{m}{n}
\rput(1.6473438,-0.37921876){-}
\usefont{T1}{ptm}{m}{n}
\rput(0.47,0.21078125){\small $r(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(3.59,-0.08921875){\small $C(z, \rho)$}
\usefont{T1}{ptm}{m}{n}
\rput(6.36,-0.10921875){\small $G_0(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(5.11,0.21078125){\small $u(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(2.21,0.21078125){\small $\xi(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(8.48,0.93078125){\small $\nu(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(9.3,0.21078125){\small $y(t)$}
\end{pspicture} 
}
\caption{Sistema de controle em malha fechada, com presença do sinal de ruído.}
\label{fig:vrft_db_control_loop}
\end{figure}

A equação \eqref{eq:vrft_db_closed_loop} descreve a relação entre entrada e saída do sistema
apresentado na Figura (\ref{fig:vrft_db_control_loop}).

\begin{equation}
T(z, \rho)=\frac{C(z,\rho)G_0(z)}{1+C(z,\rho)G_0(z)}
\label{eq:vrft_db_closed_loop}
\end{equation}

Controle baseado em dados pode ser dividido em dois grupos principais: métodos iterativos onde
experimentos são realizados sobre o sistema atualizando-se o controlador, o processo então é repetido
até que se atinja um valor minimo para a função custo deste sistema. O segundo grupo é o de métodos
não iterativos, onde apenas com um experimento, ou um conjunto de dados, os parâmetros do
controlador são estimados.

%===============================================================================
\subsection{Iterative feedback tuning}
\label{sec:vrft_control_ift}
%===============================================================================

O método IFT utiliza um algoritmo iterativo para minimizar uma função custo $H_2$. O método
considera que o sistema é controlado por um controlador com dois graus de liberdade:

\begin{equation}
u(t)=C_r(z)r(t)-C_y(z)y(t)
\label{eq:vrft_db_ift_controller}
\end{equation}

Na Figura (\ref{fig:vrft_db_ift}) é apresentado a organização dos blocos dos controladores
de \eqref{eq:vrft_db_ift_controller}, $C_r(z)$ e $C_y(z)$. O controlador pode ser
entendido como o conjunto destes dois:\cite{ift_theory_and_applications}

\begin{equation}
C(z) \equiv  \left \{ C_r(z),\, C_y(z)  \right \} 
\nonumber
\end{equation}

\begin{figure}[htbp]
\center
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-1.68)(9.48,1.72)
\usefont{T1}{ptm}{m}{n}
\rput(7.691875,1.5215625){\small $\nu(t)$}
\pscircle[linewidth=0.04,dimen=outer](4.0,0.32){0.2}
\pscircle[linewidth=0.04,dimen=outer](8.0,0.32){0.2}
\psframe[linewidth=0.04,dimen=outer](6.8,0.72)(5.2,-0.08)
\psframe[linewidth=0.04,dimen=outer](2.8,0.72)(1.2,-0.08)
\psframe[linewidth=0.04,dimen=outer](6.8,-0.88)(5.2,-1.68)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(0.0,0.32)(1.2,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(2.8,0.32)(3.8,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(4.2,0.32)(5.2,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(6.8,0.32)(7.8,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.2,0.32)(9.2,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(6.8,-1.28)(8.0,-1.28)
\psline[linewidth=0.04cm](8.0,-1.28)(8.0,0.12)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(4.0,0.12)(4.0,-1.28)
\psline[linewidth=0.04cm](4.0,-1.28)(5.2,-1.28)
\usefont{T1}{ptm}{m}{n}
\rput(8.911875,0.5215625){\small $y(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(0.481875,0.5215625){\small $r(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(1.901875,0.3215625){\small $C_r(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(5.951875,0.3215625){\small $G_0(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(5.931875,-1.2784375){\small $C_y(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(4.721875,0.7215625){\small $u(t)$}
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.0,1.32)(8.0,0.52)
\usefont{T1}{ptm}{m}{n}
\rput(4.2592187,0.1315625){-}
\end{pspicture} 
}
\caption{Diagrama de bloco do sistema utilizado na identificação IFT.}
\label{fig:vrft_db_ift}
\end{figure}

A função custo utilizada como critério no método é apresentada em \eqref{eq:vrft_db_ift_j_cost}. 

\begin{equation}
J(\rho)=\frac{1}{2N}E\left [ \sum_{t=1}^{N}(L_y \tilde{y}_t(\rho))^2 +\lambda  \sum_{t=1}^{N}(L_u
u_t(\rho))^2 \right ]
\label{eq:vrft_db_ift_j_cost}
\end{equation}

O primeiro termo em \eqref{eq:vrft_db_ift_j_cost} é o erro entre a resposta obtida e a resposta
desejada, balanceada por um filtro $L_y$ a segunda parte é o custo de controle balanceado pelo
filtro $L_u$. Com $T_0(\rho)$ e $S_0(\rho)$ sendo a função de transferência em malha fechada e a
função sensibilidade, respectivamente:


\begin{equation}
T_0(\rho)=\frac{C_r(\rho)G_0}{1+C_y(\rho)G_0}
\nonumber
\end{equation}

\begin{equation}
S_0(\rho)=\frac{1}{1+C_y(\rho)G_0}
\nonumber
\end{equation}

E sendo $r$ e $\nu$ independentes, \eqref{eq:vrft_db_ift_j_cost} pode ser rescrito como
\eqref{eq:vrft_db_ift_j_cost_parts}

\begin{equation}
J(\rho)=\frac{1}{2N}\sum_{t=1}^{N}\left \{ L_y(T_d r-T_0(\rho)r) \right \}^2+\frac{1}{2} E\left [ \left \{ L_y S_0(\rho) \nu \right \}^2 \right ]
+ \lambda \frac{1}{2N}E\left [ \sum_{t=1}^{N}(L_u u_t(\rho))^2 \right ]
\label{eq:vrft_db_ift_j_cost_parts}
\end{equation}

Onde o primeiro termo é o erro de seguimento de referência, o segundo é a contribuição do distúrbio
e o terceiro é o esforço de controle.

Para minimizar \eqref{eq:vrft_db_ift_j_cost_parts}, busca-se encontrar um ponto
estacionário da equação, para isso calcula-se o gradiente desta equação e aplica-se o
algoritmo para a convergência apresentado em \eqref{eq:vrft_db_ift_algoritm}.
\cite{hajalmson_ift_non_linear}

\begin{equation}
\rho_{i+1}=\rho_i - \gamma_i R_i^{-1}\frac{\partial J}{\partial \rho}(\rho_i)
\label{eq:vrft_db_ift_algoritm}
\end{equation}

$R_i$ é uma matriz positiva definida, tipicamente uma estimativa da Hessiana de $J$, como por
exemplo a aproximação de Gauss-Newton.

Para cada iteração $i$ em \eqref{eq:vrft_db_ift_algoritm}, o método IFT necessita de dois
experimentos, cada um de tamanho $N$. 

