%===============================================================================
\section{Introdução}
\label{sec:dbnarmax_intro}
%===============================================================================

Projeto de controladores descrito no Capítulo \ref{chapter:dbcd} tem como base a identificação de controladores
lineares. Encontram-se poucos trabalhos na literatura que abordam identificação de controladores não lineares baseados
nos dados coletados da planta. Em \cite{Guardabassi} é apresentado um procedimento para linearização de sistemas não
lineares utilizando a ideia de referência virtual. Em \cite{campi_savaresi2006} é apresentado uma generalização do
método VRFT que envolve a identificação de controladores não lineares, mas existe a necessidade de algum conhecimento
da planta e muito do sinal aplicado. O método IFT para sistemas não lineares é apresentado em
\cite{hajalmson_ift_non_linear}. No trabalho de Billings em \cite{billings_nl_survey} são apresentadas diferentes
metodologias para a identificação de sistemas não lineares.

Seguindo nesta linha, existem diversos trabalhos propondo metodologias e algoritmos para a identificação de sistemas não
lineares para inúmeras famílias de modelos. Em \cite{chen_billings1989Prediction} é apresentado uma metodologia para a
estimativa de parâmetros de sistemas não lineares, de forma recursiva. Os mesmos autores no mesmo ano apresentaram um
trabalho sobre identificação de sistemas não lineares utilizando classes de modelos NARMAX \cite{chen_billings1989}.

Existem na literatura diversos tipos de aplicações para a ideia de referência virtual, para projeto de controladores
baseados em dados, o método VRFT é talvez o mais conhecido. Neste trabalho tem-se o intuito de, baseado em referência
virtual, determinar os sinais de entrada para a utilização de algum algoritmo de identificação de sistemas não lineares.
Escolheu-se o algoritmo inicialmente proposto por \cite{billings_zhu} e que também é estudado em \cite{aguirre} por
existir um grande número de sistemas físicos e aplicações práticas que podem ser representados por esta classe de
modelos chamada de NARMAX.

%===============================================================================
\section{Definições}
\label{sec:dbnarmax_defines}
%===============================================================================

No Capítulo \ref{chapter:system_identification} foram apresentadas as definições para identificação de sistemas
lineares. Definiu-se o sistema real pelo simbolo $\mathcal{S}$, vale aqui ressaltar que para o projeto de controladores,
o sistema real que se quer identificar é o controlador ideal definido por $C_d(z)$. Define-se desta forma a classe de
controladores $\mathcal{C}$

\begin{equation}
\mathcal{C} = \left [ C(z,\theta)\;:\; \theta \in \mathcal{P} \right ]
\end{equation}
onde  $\mathcal{P} \subseteq \mathbb{R}^p$. Tem-se que o controlador ideal $C_d(z) \in \mathcal{C}$ se existir algum
$\theta_0$ que:

\begin{equation}
C(z,\theta_0)=C_d(z)
\end{equation}

Demais propriedades estatísticas e de convergência que foram apresentadas na Seção \ref{sec:sys_ident_prop_estim} podem
ser generalizadas para $C(z,\theta)$.

Para o desenvolvimento deste método supõem-se que a planta $G_0(z)$ seja não linear.

%===============================================================================
\section{Método}
\label{sec:dbnarmax_method}
%===============================================================================

O método proposto consiste na ideia de utilizar referência virtual para, a partir dos dados coletados do
sistema, determinar os sinais de entrada do controlador que fazem com que o sistema em malha fechada se comporte como
desejado: $T_d(z)$.

Parte-se do pressuposto de que o processo $G_0(z)$ é não linear, mas que o comportamento em malha fechada desejado
$T_d(z)$ seja linear, portanto o controlador projetado deve, além de cumprir com os objetivos de performance
determinados, cancelar as não linearidades da planta para que possa ser possível uma relação linear entre a entrada
$r(t)$ e a saída $y(t)$.

Apartir dos dados coletados da planta, é possível determinar os sinais de entrada do controlador utilizando
referência virtual, fazendo:

\begin{equation}
\bar{r}(t)=T_d^{-1}(z)y(t)
\label{eq:dbnarmax_method_r}
\end{equation}
e

\begin{equation}
\epsilon(t)=\bar{r}(t)-y(t)
\nonumber
\end{equation}

Na Figura \ref{fig:dbnarmax_method_vr} são presentados os sinais envolvidos e como é feita a obtenção dos sinais
necessários para a posterior identificação do controlador que leva o sistema a se comportar como esperado em malha
fechada.

\begin{figure}[htbp]
\center
% Generated with LaTeXDraw 2.0.8
% Sun Jul 15 13:50:38 BRT 2012
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-1.4292188)(9.571875,1.4692189)
\pscircle[linewidth=0.04,linestyle=dashed,dash=0.16cm 0.16cm,dimen=outer](1.951875,0.97078127){0.2}
\psframe[linewidth=0.04,linestyle=dashed,dash=0.16cm 0.16cm,dimen=outer](5.351875,1.3707813)(3.551875,0.57078123)
\psframe[linewidth=0.04,dimen=outer](8.151875,1.3707813)(6.551875,0.57078123)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(0.551875,0.97078127)(1.751875,0.97078127)
\psline[linewidth=0.04cm,linestyle=dashed,dash=0.16cm 0.16cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(2.151875,0.97078127)(3.551875,0.97078127)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(5.351875,0.97078127)(6.551875,0.97078127)
\psline[linewidth=0.04cm](8.151875,0.97078127)(9.551875,0.97078127)
\psline[linewidth=0.04cm,linestyle=dashed,dash=0.16cm 0.16cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(1.951875,0.7707813)(1.951875,-0.02921875)
\psline[linewidth=0.04cm,linestyle=dashed,dash=0.16cm 0.16cm](1.951875,-0.02921875)(8.951875,-0.02921875)
\psline[linewidth=0.04cm,linestyle=dashed,dash=0.16cm 0.16cm](8.951875,-0.02921875)(8.951875,0.97078127)
\usefont{T1}{ptm}{m}{n}
\rput(1.6271875,1.2807813){+}
\usefont{T1}{ptm}{m}{n}
\rput(2.1765625,0.68078125){-}
\usefont{T1}{ptm}{m}{n}
\rput(0.991875,1.2707813){\small $\bar{r}(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(4.511875,0.97078127){\small $C(z, \theta)$}
\usefont{T1}{ptm}{m}{n}
\rput(7.281875,0.9507812){\small $G_0(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(6.031875,1.2707813){\small $u(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(2.771875,1.2707813){\small $\epsilon (t)$}
\usefont{T1}{ptm}{m}{n}
\rput(8.821875,1.2707813){\small $y(t)$}
\psframe[linewidth=0.04,dimen=outer](6.551875,-0.62921876)(4.351875,-1.4292188)
\usefont{T1}{ptm}{m}{n}
\rput(5.431875,-1.0492188){\small $T_d^{-1}(z)$}
\psline[linewidth=0.04cm](9.551875,0.97078127)(9.551875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(9.551875,-1.0292188)(6.551875,-1.0292188)
\psline[linewidth=0.04cm](4.351875,-1.0292188)(0.551875,-1.0292188)
\psline[linewidth=0.04cm](0.551875,-1.0292188)(0.551875,0.97078127)
\end{pspicture} 
}
\caption{Representação em blocos do sistema em malha fechada para obtenção dos sinais $\epsilon(t)$ e $\bar{r}(t)$
utilizando referência virtual. Tracejado está a realimentação e o controlador, que não estão presentes no procedimento
para obtenção dos sinais.}
\label{fig:dbnarmax_method_vr}
\end{figure}

Fica a critério do projetista, assim como para métodos lineares, determinar a estrutura da classe de modelos a ser
utilizada para a identificação do controlador. Neste momento é importante ter algum conhecimento da planta, mesmo que
isso não seja mandatório para que o método possa ser aplicado. Para que o comportamento linear $T_d(z)$ possa ser obtido
em malha fechada há a necessidade de que o controlador $C_d(z) \in C(z, \theta)$. $C_d(z)$ neste caso é o mesmo que o
apresentado na equação \eqref{eq:dbcd_perf_tracking_cd} e aqui replicado:

\begin{equation}
C_d(z)=\frac{T_d(z)}{G_0(z)(1-T_d(z))}
\label{eq:dbnarmax_perf_tracking_cd}
\end{equation}

Desta forma é simples compreender que $G_0(z)$, ou uma parcela deste, estará presente na estrutura de $C(z,\theta)$.
Como foi suposto anteriormente na Seção \ref{sec:dbnarmax_defines}, a planta é não linear. Desta forma o controlador
será também não linear, devido ao relacionamento apresentado em \eqref{eq:dbnarmax_perf_tracking_cd}. Supõem-se ainda
que o controlador pode ser descrito por uma classe de modelos NARMAX.

Não é apenas devido a planta ser não linear e o comportamento em malha fechada ser linear que o controlador ideal
possuirá um comportamento não linear. Pode-se a partir de um comportamento em malha fechada não linear e com uma planta
linear ou não, obter-se um controlador que também seja não linear linear, dependendo das especificações que o
controlador é submetido. 

A classe de modelos NARMAX é subdividida em dois grupos principais: polinomial

\begin{equation}
y(t)=\sum_{m=0}^{l}\sum_{p=0}^{m}\sum_{n1, n_m}^{n_y, n_u}c_{p,m-p}(n_1,...,n_m)\prod_{i=1}^{p}y(t-n_i)\prod_{i=p+1}^{m}u(t-n_i)
\nonumber
\end{equation}
e racional:

\begin{align*}
y(t) &=\frac{a(y(t-1), \ldots, y(t-n_y), u(t-1),\ldots, u(t-n_u), }{b(y(t-1), \ldots, y(t-n_y), u(t-1), \ldots, u(t-n_u),}\cdots \\ 
& \cdots\frac{ e(t-1), \ldots, e(t-n_e))}{e(t-1), \ldots, e(t-n_e))} +e(t)
\end{align*}

O algoritmo proposto na Seção \ref{sec:nl_si_algorithms_rationals} pode ser aplicado para a identificação do controlador
que sobre as circunstâncias apresentadas será NARMAX.

%===============================================================================
\subsection{Outras classes}
\label{sec:dbnarmax_other_classes}
%===============================================================================

É conveniente observar que a escolha da classe NARMAX está intimamente ligada ao uso do algoritmo de identificação
destes modelos ter-se mostrado bastante eficiente, como foi apresentado nos exemplos da Seção
\ref{sec:nl_si_algorithms_rationals_examples}, além dos motivos já citados da vasta gama de sistemas reais que modelos
NARMAX conseguem representar. Todavia, a metodologia apresentada, poderia ser aplicada para qualquer classe de modelos
de sistemas não lineares, onde algum algoritmo para identificação deste tipo de classe pudesse ser utilizado para
obtenção dos valores de $\hat{\theta}$ que minimize algum critério de escolha. Uma das poucas limitações seria que este
algoritmo deve identificar o controlador baseado nos dados de entrada e saída da planta e dos sinais virtuais gerados a
partir destes dados.

A qualidade das estimativas obtidas é bastante relacionada com a qualidade do algoritmo em estimar os valores de
$\theta$ que minimizam alguma função custo. Entretanto tudo que foi abordado referente a identificabilidade de um
experimento e a ordem de excitação de um sinal, determinam as condições básicas para que o resultado obtido seja livre
de erro de polarização.

