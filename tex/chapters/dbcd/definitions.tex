%===============================================================================
\section{Definições}
\label{sec:dbcd_definition}
%===============================================================================

Desde meados dos anos 1990 uma variedade de projetos de controladores que são construidos diretamente sobre os dados de
entrada e saída coletados do sistema tem surgido na literatura. Estes métodos contrastam com os de projetos de
controladores baseados em modelos em dois aspectos principais: eles não são baseados no conhecimento do modelo do
processo e eles não tem a intenção de determinar livremente a função de transferência do modelo. Ao invéz disso usa-se
diretamente o montante de informação carregada pelos dados coletados para ajustar os parametros de um conjunto de
modelos cuja estrutura é previamente especificada. \cite{bazanella_datadriven} 

Estes métodos são conhecidos como projeto de controladores baseados em dados ou do ingles {\it{data-driven or data
based controller design}}.

Como já foi discutido na seção (\ref{sec:si_project_experiments}) estes dados podem ser obtidos de
diversas formas. Algumas vezes estas informações podem vir da operação normal da planta em malha
fechada com a presença de algum controlador. Situação esta que tem um grande apelo em plantas
industriais, onde a parada do processo, para levantamento de informações, é indesejável e muitas
vezes até inviável. Se existe a possibilidade de parar a planta e aplicar sinais predeterminados,
o projeto de experimentos pode trazer muitas vantagens (seção \ref{sec:si_project_experiments}).

O projeto de controladores baseados em dados consiste em estimar os parametros da estrutura do controlador usando os
dados de entrada e saída coletados do sistema. A estimativa é feita de forma direta, ou seja, sem a necessidade de um
passo intermediário para identificação da planta do processo. \cite{eckard_campestrini}

Existem na literatura diversos métodos de projetos de controladores baseados em dados que otimizam algum critério de
performance, com diferentes focos para diferentes critérios. Estes critérios expressam um ou uma combinação de objetivos
fundamentais de controle: seguimento de referência, rejeição a ruído e uso economico da energia de controle.
Em \cite{Kammer2000} um procedimento iterativo baseado na análise espectral chamado de {\it{Frequency Domain Tuning}}
(FDT) foi proposto para a minimização do critério $H_2$ de performance para um sistema com referência zero, portanto
sem nenhum objetivo de seguimento de referência é almejado. O método {\it{Virtual Reference Feedback Tuning}} (VRFT)
\cite{campi_leccini_savaresi2002, campi_savaresi2006} é baseado na manipulação de variáveis que transformam um
critério $H_2$ em algo quadrático nos parametros. A função custo quadrática resultante pode ser minimizado
diretamente, sem que nenhuma iteração seja necessária. Entretanto apenas o objetivo de seguimento de referência é
tratato (a não ser que um controlador com dois níveis de liberdade seja usado \cite{lecchini_campi_savaresi_2dof}) e o minimo
global resultante desta função quadráica coincide com o do critério original somente sob condições ideais.
{\it{Correlation-based Tuning}} (CbT) \cite{ Karimi_cbt2003, Karimi_cbt2004} não sofre desta segunda limitação, mas é
um método iterativo que usa a ideia de variáveis instrumentais para remover o efeito indesejado do ruído enquanto
busca seu objetivo de seguimento de referência. \cite{Bazanella_h2criteria2008} 

Otimização baseada em dados para um critério de performance genérico $H_2$ foi proposto em \cite{Hjalmarsson1994}, onde
um método para obter estimativas não polarizadas diretamente do gradiente da função custo apartir de dados do sistema em
malha fechada foi elaborado. Este método é chamado de {\it{Iterative Feedback Tuning}} (IFT). IFT é discutido a fundo em
\cite{Hjalmarsson_ift1998, Hjalmarsson2002} e extendido em \cite{Prochazka2005} para critério de performances mais
gerais, que contém melhorias em objetivos de robustes. \cite{Bazanella_h2criteria2008} 

Seja a esperança de um valor $E\left [ \cdot \right ]$ definido por: \cite{ljung}

\begin{equation}
\bar{E}\left [ f(t) \right ]\equiv \lim_{N \to \infty } \frac{1}{N}\sum_{t=1}^{N}E\left [ f(t)
\right]
\label{eq:vrft_db_hope}
\end{equation}

O ruído é um processo quasi-estacionário, que pode ser descrito como $\nu(t)=H_0(z)e(t)$, onde
$e(t)$ é ruído branco com variância $\sigma_e^2(t)$. Ambas funções de transferência, $G_0(z)$ e $H_0(z)$,
são racionais e causais. Assume-se que $H(\infty)=1$, ou seja, a resposta impulsiva do filtro
$H_0(z)$ satisfaz $h(0)=1$. \cite{campestrini}

Na Figura (\ref{fig:vrft_db_control_loop}) é apresentado um usual sistema com realimentação de saída onde são
destacados os blocos do controlador, da planta e da funçaõ que modifica o ruído branco $e(t)$.

\begin{figure}[htbp]
\center
% Generated with LaTeXDraw 2.0.8
% Tue Jun 05 22:30:25 BRT 2012
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-2.0492187)(9.84,2.0692186)
\pscircle[linewidth=0.04,dimen=outer](1.401875,-1.0292188){0.2}
\psframe[linewidth=0.04,dimen=outer](4.401875,-0.62921876)(2.601875,-1.4292188)
\psframe[linewidth=0.04,dimen=outer](7.201875,-0.62921876)(5.601875,-1.4292188)
\pscircle[linewidth=0.04,dimen=outer](8.401875,-1.0292188){0.2}
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(0.001875,-1.0292188)(1.201875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(1.601875,-1.0292188)(2.601875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(4.401875,-1.0292188)(5.601875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(7.201875,-1.0292188)(8.201875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.4,0.16921872)(8.401875,-0.82921875)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.601875,-1.0292188)(9.801875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(1.401875,-1.2292187)(1.401875,-2.0292187)
\psline[linewidth=0.04cm](1.401875,-2.0292187)(9.201875,-2.0292187)
\psline[linewidth=0.04cm](9.201875,-2.0292187)(9.201875,-1.0292188)
\usefont{T1}{ptm}{m}{n}
\rput(1.0771874,-0.7192188){+}
\usefont{T1}{ptm}{m}{n}
\rput(8.0771885,-0.7192188){+}
\usefont{T1}{ptm}{m}{n}
\rput(8.0771885,-1.3192188){+}
\usefont{T1}{ptm}{m}{n}
\rput(1.6265626,-1.3192188){-}
\usefont{T1}{ptm}{m}{n}
\rput(0.441875,-0.7292188){\small $r(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(3.561875,-1.0292188){\small $C(z, \theta)$}
\usefont{T1}{ptm}{m}{n}
\rput(6.331875,-1.0492188){\small $G_0(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(5.081875,-0.7292188){\small $u(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(1.941875,-0.7292188){\small $\varepsilon (t)$}
\usefont{T1}{ptm}{m}{n}
\rput(7.851875,-0.20921877){\small $\nu(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(9.271875,-0.7292188){\small $y(t)$}
\psframe[linewidth=0.04,dimen=outer](9.201875,0.9707812)(7.601875,0.17078124)
\usefont{T1}{ptm}{m}{n}
\rput(8.331875,0.55078125){\small $H_0(z)$}
\psline[linewidth=0.04cm](8.4,0.96921873)(8.4,1.5692188)
\usefont{T1}{ptm}{m}{n}
\rput(8.271875,1.8707812){\small $e(t)$}
\end{pspicture} 
}
\caption{Sistema de controle em malha fechada, com presença do sinal de ruído.}
\label{fig:vrft_db_control_loop}
\end{figure}

A equação: 

\begin{equation}
T(z, \theta)=\frac{C(z,\theta)G_0(z)}{1+C(z,\theta)G_0(z)}
\label{eq:vrft_db_closed_loop}
\end{equation}

Descreve a relação entre entrada e saída do sistema apresentado na Figura (\ref{fig:vrft_db_control_loop}).  Em outras
palavras:

\begin{equation}
y(t)=T(z, \theta)r(t)
\label{eq:dbcd_def_yr}
\end{equation}

%===============================================================================
\subsection{Critérios de performance}
\label{sec:dbcd_performance_criteria}
%===============================================================================

Como já foi apresentado para identificação de sistemas, existe um critério para elencar qual é o melhor conjunto de
parametros $\theta$ pra a classe de modelos escolhida. Para identificação de sistemas lineares, foi apresentado na
equação \eqref{eq:si_obj_etim_lsm_v} um dos critérios mais utilizados. Para sistemas de controle existem desdobramentos
deste critério em função dos objetivos básicos de controle: Seguimento de referência, rejeição a ruído e uso reduzido de
esforço de controle.

Um destes objetivos fundamentais de sistemas de controle é fazer a saída do processo a mais próxima possível da
referência. A performance, por este ponto de vista pode ser avaliado pela norma: \cite{bazanella_datadriven}

\begin{equation}
J_y(\theta)\overset{\underset{\mathrm{\Delta}}{\,}}{=}  \bar{E} \left [ y(t)-y_d(t) \right ]^2 = \bar{E}\left [
(T(z,\theta)-T_d(z))r(t) \right ]^2
\label{eq:dbcd_def_track_error}
\end{equation}

Onde $y(t)$ é a saída medida do sistema e $y_d(t)$ é a saída desejada.

Com base nas equações \eqref{eq:dbcd_def_track_error} e \eqref{eq:vrft_db_closed_loop} é possível determinar o
equacionamento para o controlador ideal ou desejado. Aquele que irá fazer com que o sistema em malha fechada se comporte como o
desejado.

\begin{equation}
C_d(z)=\frac{T_d(z)}{G_0(z)(1-T_d(z))}
\label{eq:dbcd_perf_tracking_cd}
\end{equation}
























%===============================================================================
\subsection{Iterative feedback tuning}
\label{sec:dbcd_ift}
%===============================================================================

O método IFT utiliza um algoritmo iterativo para minimizar uma função custo $H_2$. O método
considera que o sistema é controlado por um controlador com dois graus de liberdade:

\begin{equation}
u(t)=C_r(z)r(t)-C_y(z)y(t)
\label{eq:vrft_db_ift_controller}
\end{equation}

Na Figura (\ref{fig:vrft_db_ift}) é apresentado a organização dos blocos dos controladores
de \eqref{eq:vrft_db_ift_controller}, $C_r(z)$ e $C_y(z)$. O controlador pode ser
entendido como o conjunto destes dois:\cite{Hjalmarsson_ift1998}

\begin{equation}
C(z) \equiv  \left \{ C_r(z),\, C_y(z)  \right \} 
\nonumber
\end{equation}

\begin{figure}[htbp]
\center
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-1.68)(9.48,1.72)
\usefont{T1}{ptm}{m}{n}
\rput(7.691875,1.5215625){\small $\nu(t)$}
\pscircle[linewidth=0.04,dimen=outer](4.0,0.32){0.2}
\pscircle[linewidth=0.04,dimen=outer](8.0,0.32){0.2}
\psframe[linewidth=0.04,dimen=outer](6.8,0.72)(5.2,-0.08)
\psframe[linewidth=0.04,dimen=outer](2.8,0.72)(1.2,-0.08)
\psframe[linewidth=0.04,dimen=outer](6.8,-0.88)(5.2,-1.68)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(0.0,0.32)(1.2,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(2.8,0.32)(3.8,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(4.2,0.32)(5.2,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(6.8,0.32)(7.8,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.2,0.32)(9.2,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(6.8,-1.28)(8.0,-1.28)
\psline[linewidth=0.04cm](8.0,-1.28)(8.0,0.12)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(4.0,0.12)(4.0,-1.28)
\psline[linewidth=0.04cm](4.0,-1.28)(5.2,-1.28)
\usefont{T1}{ptm}{m}{n}
\rput(8.911875,0.5215625){\small $y(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(0.481875,0.5215625){\small $r(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(1.901875,0.3215625){\small $C_r(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(5.951875,0.3215625){\small $G_0(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(5.931875,-1.2784375){\small $C_y(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(4.721875,0.7215625){\small $u(t)$}
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.0,1.32)(8.0,0.52)
\usefont{T1}{ptm}{m}{n}
\rput(4.2592187,0.1315625){-}
\end{pspicture} 
}
\caption{Diagrama de bloco do sistema utilizado na identificação IFT.}
\label{fig:vrft_db_ift}
\end{figure}

A função custo utilizada como critério no método é apresentada em \eqref{eq:vrft_db_ift_j_cost}. 

\begin{equation}
J(\theta)=\frac{1}{2N}E\left [ \sum_{t=1}^{N}(L_y \tilde{y}_t(\theta))^2 +\lambda  \sum_{t=1}^{N}(L_u
u_t(\theta))^2 \right ]
\label{eq:vrft_db_ift_j_cost}
\end{equation}

O primeiro termo em \eqref{eq:vrft_db_ift_j_cost} é o erro entre a resposta obtida e a resposta
desejada, balanceada por um filtro $L_y$ a segunda parte é o custo de controle balanceado pelo
filtro $L_u$. Com $T_0(\theta)$ e $S_0(\theta)$ sendo a função de transferência em malha fechada e a
função sensibilidade, respectivamente:


\begin{equation}
T_0(\theta)=\frac{C_r(\theta)G_0}{1+C_y(\theta)G_0}
\nonumber
\end{equation}

\begin{equation}
S_0(\theta)=\frac{1}{1+C_y(\theta)G_0}
\nonumber
\end{equation}

E sendo $r$ e $\nu(t)$ independentes, \eqref{eq:vrft_db_ift_j_cost} pode ser rescrito como
\eqref{eq:vrft_db_ift_j_cost_parts}

\begin{equation}
J(\theta)=\frac{1}{2N}\sum_{t=1}^{N}\left \{ L_y(T_d r-T_0(\theta)r) \right \}^2+\frac{1}{2} E\left [ \left \{ L_y S_0(\theta) \nu(t) \right \}^2 \right ]
+ \lambda \frac{1}{2N}E\left [ \sum_{t=1}^{N}(L_u u_t(\theta))^2 \right ]
\label{eq:vrft_db_ift_j_cost_parts}
\end{equation}

Onde o primeiro termo é o erro de seguimento de referência, o segundo é a contribuição do distúrbio
e o terceiro é o esforço de controle.

Para minimizar \eqref{eq:vrft_db_ift_j_cost_parts}, busca-se encontrar um ponto
estacionário da equação, para isso calcula-se o gradiente desta equação e aplica-se o
algoritmo para a convergência apresentado em \eqref{eq:vrft_db_ift_algoritm}.
\cite{hajalmson_ift_non_linear}

\begin{equation}
\theta_{i+1}=\theta_i - \gamma_i R_i^{-1}\frac{\partial J}{\partial \theta}(\theta_i)
\label{eq:vrft_db_ift_algoritm}
\end{equation}

$R_i$ é uma matriz positiva definida, tipicamente uma estimativa da Hessiana de $J$, como por
exemplo a aproximação de Gauss-Newton.

Para cada iteração $i$ em \eqref{eq:vrft_db_ift_algoritm}, o método IFT necessita de dois
experimentos, cada um de tamanho $N$. 

