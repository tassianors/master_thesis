%===============================================================================
\section{Definições}
\label{sec:dbcd_definition}
%===============================================================================
O projeto de controladores baseados em dados consiste em obter, ou estimar, os parâmetros de uma família ou conjunto de 
modelos baseados nos dados obtidos da planta sob análise. Os dados utilizados para esta tarefa são usualmente os sinais
de entrada e saída do sistema.

Como já foi discutido na seção (\ref{sec:si_project_experiments}) estes dados podem ser obtidos de
diversas formas. Algumas vezes estas informações podem vir da operação normal da planta em malha
fechada com a presença de algum controlador. Situação esta que tem um grande apelo em plantas
industriais, onde a parada do processo, para levantamento de informações, é indesejável e muitas
vezes até inviável. Se existe a possibilidade de parar a planta e aplicar sinais predeterminados,
o projeto de experimentos pode trazer muitas vantagens (seção \ref{sec:si_project_experiments}).

O projeto de controladores baseados em dados consiste em estimar os parametros da estrutura do controlador usando os
dados de entrada e saída coletados do sistema. A estimativa é feita de forma direta, ou seja, sem a necessidade de um
passo intermediário para identificação da planta do processo. \cite{eckard_campestrini}

% http://www.sciencedirect.com/science/article/pii/S0005109808002288
% Several data-based control design methods explicitly optimizing performance criteria have appeared in the
% literature, with different approaches and for different performance criteria. These criteria express either one or a combination  of
% the fundamental control objectives: reference tracking, noise rejection, and economic use of control energy. In Kammer,
% Bitmead, and Bartlett (2000) an iterative procedure based on spectral analysis, named Frequency Domain Tuning (FDT), 
% has been proposed for the minimization of an H2 performance criterion for a system with zero reference; hence, no
% tracking objective is pursued. The Virtual Reference Feedback Tuning (VRFT) method ( [Campi et al., 2002] and [Campi
% and Savaresi, 2006]) is based on a clever manipulation of variables which transforms an H2 performance criterion into
% one which is quadratic in the design parameters. The resulting quadratic cost function can be minimized directly, so
% that no iterations are required. However, only the reference tracking objective is treated (unless a two degree of
% freedom controller is used, as in Lecchini, Campi, and Savaresi (2002)) and the global minimum of the resulting
% quadratic function coincides with that of the original criterion only under ideal conditions. Not suffering from this
% second limitation, but again an iterative procedure, is Correlation-based Tuning (CbT) ( [Karimi et al., 2003] and
% [Karimi et al., 2004]), which uses instrumental variable ideas to eliminate the deleterious effect of noise on the
% achievement of its reference tracking objective. Data-based optimization of a general H2 performance criterion appears
% in Hjalmarsson, Gunnarsson, and Gevers (1994). There, a method for obtaining an unbiased estimate of the gradient of
% the cost function directly from closed-loop data is proposed; this method has been named Iterative Feedback Tuning
% (IFT). IFT is discussed in depth in Hjalmarsson, Gevers, Gunnarsson, and Lequin (1998), Hjalmarsson (2002) and
% extended in Procházka, Gevers, Anderson, and Ferrera (2005) to even more general performance criteria, which contain
% robustness enhancement objectives.
 
Existem na literatura diversos métodos de projetos de controladores baseados em dados que otimizam algum critério de
performance, com diferentes focos para diferentes critérios. Estes critérios expressam um ou uma combinação de objetivos
fundamentais de controle: seguimento de referência, rejeição a ruído e uso economico da energia de controle.
Em \cite{Kammer2000} um procedimento iterativo baseado na análise espectral chamado de {\it{Frequency Domain Tuning}}
(FDT) foi proposto para a minimização do critério $H_2$ de performance para um sistema com referência zero, portanto
sem nenhum objetivo de seguimento de referência é almejado. O método {\it{Virtual Reference Feedback Tuning}} (VRFT)
\cite{campi_leccini_savaresi2002, campi_savaresi2006} é baseado na manipulação de variáveis que transformam um
critério $H_2$ em algo quadrático nos parametros. A função custo quadrática resultante pode ser minimizado
diretamente, sem que nenhuma iteração seja necessária. Entretanto apenas o objetivo de seguimento de referência é
tratato (a não ser que um controlador com dois níveis de liberdade seja usado \cite{lecchini_campi_savaresi_2dof}) e o minimo
global resultante desta função quadráica coincide com o do critério original somente sob condições ideais.
{\it{Correlation-based Tuning}} (CbT) \cite{ Karimi_cbt2003, Karimi_cbt2004} não sofre desta segunda limitação, mas é
um método iterativo que usa a ideia de variáveis instrumentais para remover o efeito indesejado do ruído enquanto
busca seu objetivo de seguimento de referência. \cite{Bazanella_h2criteria2008} 

Otimização baseada em dados para um critério de performance genérico $H_2$ foi proposto em \cite{Hjalmarsson1994}, onde
um método para obter estimativas não polarizadas diretamente do gradiente da função custo apartir de dados do sistema em
malha fechada foi elaborado. Este método é chamado de {\it{Iterative Feedback Tuning}} (IFT). IFT é discutido a fundo em
\cite{Hjalmarsson_ift1998, Hjalmarsson2002} e extendido em \cite{Prochazka2005} para critério de performances mais
gerais, que contém melhorias em objetivos de robustes. \cite{Bazanella_h2criteria2008} 

Seja a esperança de um valor $E\left [ \cdot \right ]$ definido por: \cite{ljung}

\begin{equation}
\bar{E}\left [ f(t) \right ]\equiv \lim_{N \to \infty } \frac{1}{N}\sum_{t=1}^{N}E\left [ f(t)
\right]
\label{eq:vrft_db_hope}
\end{equation}

O ruído é um processo quasi-estacionário, que pode ser descrito como $\nu(t)=H_0(z)e(t)$, onde
$e(t)$ é ruído branco com variância $\sigma_e^2(t)$. Ambas funções de transferência, $G_0(z)$ e $H_0(z)$,
são racionais e causais. Assume-se que $H(\infty)=1$, ou seja, a resposta impulsiva do filtro
$H_0(z)$ satisfaz $h(0)=1$. \cite{campestrini}

Na Figura (\ref{fig:vrft_db_control_loop}) é apresentado um usual sistema com realimentação de saída onde são
destacados os blocos do controlador, da planta e da funçaõ que modifica o ruído branco $e(t)$.

\begin{figure}[htbp]
\center
% Generated with LaTeXDraw 2.0.8
% Tue Jun 05 22:30:25 BRT 2012
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-2.0492187)(9.84,2.0692186)
\pscircle[linewidth=0.04,dimen=outer](1.401875,-1.0292188){0.2}
\psframe[linewidth=0.04,dimen=outer](4.401875,-0.62921876)(2.601875,-1.4292188)
\psframe[linewidth=0.04,dimen=outer](7.201875,-0.62921876)(5.601875,-1.4292188)
\pscircle[linewidth=0.04,dimen=outer](8.401875,-1.0292188){0.2}
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(0.001875,-1.0292188)(1.201875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(1.601875,-1.0292188)(2.601875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(4.401875,-1.0292188)(5.601875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(7.201875,-1.0292188)(8.201875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.4,0.16921872)(8.401875,-0.82921875)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.601875,-1.0292188)(9.801875,-1.0292188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(1.401875,-1.2292187)(1.401875,-2.0292187)
\psline[linewidth=0.04cm](1.401875,-2.0292187)(9.201875,-2.0292187)
\psline[linewidth=0.04cm](9.201875,-2.0292187)(9.201875,-1.0292188)
\usefont{T1}{ptm}{m}{n}
\rput(1.0771874,-0.7192188){+}
\usefont{T1}{ptm}{m}{n}
\rput(8.0771885,-0.7192188){+}
\usefont{T1}{ptm}{m}{n}
\rput(8.0771885,-1.3192188){+}
\usefont{T1}{ptm}{m}{n}
\rput(1.6265626,-1.3192188){-}
\usefont{T1}{ptm}{m}{n}
\rput(0.441875,-0.7292188){\small $r(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(3.561875,-1.0292188){\small $C(z, \rho)$}
\usefont{T1}{ptm}{m}{n}
\rput(6.331875,-1.0492188){\small $G_0(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(5.081875,-0.7292188){\small $u(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(1.941875,-0.7292188){\small $\varepsilon (t)$}
\usefont{T1}{ptm}{m}{n}
\rput(7.851875,-0.20921877){\small $\nu(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(9.271875,-0.7292188){\small $y(t)$}
\psframe[linewidth=0.04,dimen=outer](9.201875,0.9707812)(7.601875,0.17078124)
\usefont{T1}{ptm}{m}{n}
\rput(8.331875,0.55078125){\small $H_0(z)$}
\psline[linewidth=0.04cm](8.4,0.96921873)(8.4,1.5692188)
\usefont{T1}{ptm}{m}{n}
\rput(8.271875,1.8707812){\small $e(t)$}
\end{pspicture} 
}
\caption{Sistema de controle em malha fechada, com presença do sinal de ruído.}
\label{fig:vrft_db_control_loop}
\end{figure}

A equação \eqref{eq:vrft_db_closed_loop} descreve a relação entre entrada e saída do sistema
apresentado na Figura (\ref{fig:vrft_db_control_loop}).

\begin{equation}
T(z, \rho)=\frac{C(z,\rho)G_0(z)}{1+C(z,\rho)G_0(z)}
\label{eq:vrft_db_closed_loop}
\end{equation}

projeto de controladires baseados em dados podem ser divididos em dois grupos principais: métodos iterativos onde
experimentos são realizados sobre o sistema atualizando-se o controlador a cada iteração, repete-se o processo  até que
se atinja um valor minimo para a função custo. O segundo grupo é o de métodos não iterativos, onde apenas com um
experimento, ou um conjunto de dados, os parâmetros do controlador são estimados.

%===============================================================================
\subsection{Iterative feedback tuning}
\label{sec:vrft_control_ift}
%===============================================================================

O método IFT utiliza um algoritmo iterativo para minimizar uma função custo $H_2$. O método
considera que o sistema é controlado por um controlador com dois graus de liberdade:

\begin{equation}
u(t)=C_r(z)r(t)-C_y(z)y(t)
\label{eq:vrft_db_ift_controller}
\end{equation}

Na Figura (\ref{fig:vrft_db_ift}) é apresentado a organização dos blocos dos controladores
de \eqref{eq:vrft_db_ift_controller}, $C_r(z)$ e $C_y(z)$. O controlador pode ser
entendido como o conjunto destes dois:\cite{Hjalmarsson_ift1998}

\begin{equation}
C(z) \equiv  \left \{ C_r(z),\, C_y(z)  \right \} 
\nonumber
\end{equation}

\begin{figure}[htbp]
\center
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-1.68)(9.48,1.72)
\usefont{T1}{ptm}{m}{n}
\rput(7.691875,1.5215625){\small $\nu(t)$}
\pscircle[linewidth=0.04,dimen=outer](4.0,0.32){0.2}
\pscircle[linewidth=0.04,dimen=outer](8.0,0.32){0.2}
\psframe[linewidth=0.04,dimen=outer](6.8,0.72)(5.2,-0.08)
\psframe[linewidth=0.04,dimen=outer](2.8,0.72)(1.2,-0.08)
\psframe[linewidth=0.04,dimen=outer](6.8,-0.88)(5.2,-1.68)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(0.0,0.32)(1.2,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(2.8,0.32)(3.8,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(4.2,0.32)(5.2,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(6.8,0.32)(7.8,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.2,0.32)(9.2,0.32)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(6.8,-1.28)(8.0,-1.28)
\psline[linewidth=0.04cm](8.0,-1.28)(8.0,0.12)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(4.0,0.12)(4.0,-1.28)
\psline[linewidth=0.04cm](4.0,-1.28)(5.2,-1.28)
\usefont{T1}{ptm}{m}{n}
\rput(8.911875,0.5215625){\small $y(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(0.481875,0.5215625){\small $r(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(1.901875,0.3215625){\small $C_r(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(5.951875,0.3215625){\small $G_0(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(5.931875,-1.2784375){\small $C_y(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(4.721875,0.7215625){\small $u(t)$}
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.0,1.32)(8.0,0.52)
\usefont{T1}{ptm}{m}{n}
\rput(4.2592187,0.1315625){-}
\end{pspicture} 
}
\caption{Diagrama de bloco do sistema utilizado na identificação IFT.}
\label{fig:vrft_db_ift}
\end{figure}

A função custo utilizada como critério no método é apresentada em \eqref{eq:vrft_db_ift_j_cost}. 

\begin{equation}
J(\rho)=\frac{1}{2N}E\left [ \sum_{t=1}^{N}(L_y \tilde{y}_t(\rho))^2 +\lambda  \sum_{t=1}^{N}(L_u
u_t(\rho))^2 \right ]
\label{eq:vrft_db_ift_j_cost}
\end{equation}

O primeiro termo em \eqref{eq:vrft_db_ift_j_cost} é o erro entre a resposta obtida e a resposta
desejada, balanceada por um filtro $L_y$ a segunda parte é o custo de controle balanceado pelo
filtro $L_u$. Com $T_0(\rho)$ e $S_0(\rho)$ sendo a função de transferência em malha fechada e a
função sensibilidade, respectivamente:


\begin{equation}
T_0(\rho)=\frac{C_r(\rho)G_0}{1+C_y(\rho)G_0}
\nonumber
\end{equation}

\begin{equation}
S_0(\rho)=\frac{1}{1+C_y(\rho)G_0}
\nonumber
\end{equation}

E sendo $r$ e $\nu$ independentes, \eqref{eq:vrft_db_ift_j_cost} pode ser rescrito como
\eqref{eq:vrft_db_ift_j_cost_parts}

\begin{equation}
J(\rho)=\frac{1}{2N}\sum_{t=1}^{N}\left \{ L_y(T_d r-T_0(\rho)r) \right \}^2+\frac{1}{2} E\left [ \left \{ L_y S_0(\rho) \nu \right \}^2 \right ]
+ \lambda \frac{1}{2N}E\left [ \sum_{t=1}^{N}(L_u u_t(\rho))^2 \right ]
\label{eq:vrft_db_ift_j_cost_parts}
\end{equation}

Onde o primeiro termo é o erro de seguimento de referência, o segundo é a contribuição do distúrbio
e o terceiro é o esforço de controle.

Para minimizar \eqref{eq:vrft_db_ift_j_cost_parts}, busca-se encontrar um ponto
estacionário da equação, para isso calcula-se o gradiente desta equação e aplica-se o
algoritmo para a convergência apresentado em \eqref{eq:vrft_db_ift_algoritm}.
\cite{hajalmson_ift_non_linear}

\begin{equation}
\rho_{i+1}=\rho_i - \gamma_i R_i^{-1}\frac{\partial J}{\partial \rho}(\rho_i)
\label{eq:vrft_db_ift_algoritm}
\end{equation}

$R_i$ é uma matriz positiva definida, tipicamente uma estimativa da Hessiana de $J$, como por
exemplo a aproximação de Gauss-Newton.

Para cada iteração $i$ em \eqref{eq:vrft_db_ift_algoritm}, o método IFT necessita de dois
experimentos, cada um de tamanho $N$. 

