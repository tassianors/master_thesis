%===============================================================================
\section{Definições}
\label{sec:dbcd_definition}
%===============================================================================

Desde meados dos anos 1990  têm surgido na literatura uma variedade de projetos de controladores que são construidos
diretamente sobre os dados de entrada e saída coletados do sistema. Estes métodos contrastam com os de projetos de
controladores baseados em modelos em dois aspectos principais: eles não são baseados no conhecimento do modelo do
processo e eles não tem a intenção de determinar livremente a função de transferência do modelo. Ao invéz disso usa-se
diretamente o montante de informação carregada pelos dados coletados para ajustar os parametros de um conjunto de
modelos cuja estrutura é previamente especificada. \cite{bazanella_datadriven} 

Estes métodos são conhecidos como projeto de controladores baseados em dados ou do ingles {\it{data-driven or data
based controller design}}.

Como apresentado na seção (\ref{sec:si_project_experiments}) estes dados podem ser obtidos de
diversas formas. Algumas vezes estas informações podem vir da operação normal da planta em malha
fechada com a presença de algum controlador. Situação esta que tem um grande apelo em plantas
industriais, onde a parada do processo, para levantamento de informações, é muitas vezes indesejável por vezes até
inviável. Se existe a possibilidade de parar a planta e aplicar sinais predeterminados, o projeto de experimentos pode
trazer muitas vantagens (seção \ref{sec:si_project_experiments}).

O projeto de controladores baseados em dados consiste em estimar os parametros da estrutura do controlador usando os
dados de entrada e saída coletados do sistema. A estimativa é feita de forma direta, ou seja, sem a necessidade de um
passo intermediário para identificação da planta do processo. \cite{eckard_campestrini}

Existem na literatura diversos métodos de projetos de controladores baseados em dados que otimizam algum critério de
performance, com diferentes focos para diferentes critérios. Estes critérios expressam um ou uma combinação de objetivos
fundamentais de controle: seguimento de referência, rejeição a ruído e uso economico da energia de controle.
Em \cite{Kammer2000} um procedimento iterativo baseado na análise espectral chamado de {\it{Frequency Domain Tuning}}
(FDT) foi proposto para a minimização do critério $H_2$ de performance para um sistema com referência zero, portanto
sem nenhum objetivo de seguimento de referência é almejado. O método {\it{Virtual Reference Feedback Tuning}} (VRFT)
\cite{campi_leccini_savaresi2002, campi_savaresi2006} é baseado na manipulação de variáveis que transformam um
critério $H_2$ em algo quadrático nos parametros. A função custo quadrática resultante pode ser minimizado
diretamente, sem que nenhuma iteração seja necessária. Entretanto apenas o objetivo de seguimento de referência é
tratato (a não ser que um controlador com dois níveis de liberdade seja usado \cite{lecchini_campi_savaresi_2dof}) e o minimo
global resultante desta função quadráica coincide com o do critério original somente sob condições ideais.
{\it{Correlation-based Tuning}} (CbT) \cite{ Karimi_cbt2003, Karimi_cbt2004} não sofre desta segunda limitação, mas é
um método iterativo que usa a ideia de variáveis instrumentais para remover o efeito indesejado do ruído enquanto
busca seu objetivo de seguimento de referência. \cite{Bazanella_h2criteria2008} 

Otimização baseada em dados para um critério de performance genérico $H_2$ foi proposto em \cite{Hjalmarsson1994}, onde
um método para obter estimativas não polarizadas diretamente do gradiente da função custo, apartir de dados do sistema
em malha fechada, foi elaborado. Este método é chamado de {\it{Iterative Feedback Tuning}} (IFT). IFT é discutido a
fundo em \cite{Hjalmarsson_ift1998, Hjalmarsson2002} e extendido em \cite{Prochazka2005} para critério de performances mais
gerais, que contém melhorias em objetivos de robustes. \cite{Bazanella_h2criteria2008} 

Na Figura (\ref{fig:vrft_db_control_loop}) é apresentado um usual sistema com realimentação de saída onde são
destacados os blocos do controlador, da planta e da funçaõ que modifica o ruído branco $e(t)$.

O ruído é um processo quasi-estacionário, que pode ser descrito como $\nu(t)=H_0(z)e(t)$, onde
$e(t)$ é ruído branco com variância $\sigma_e^2(t)$. Ambas funções de transferência, $G_0(z)$ e $H_0(z)$,
são racionais e causais. Assume-se que $H_0(\infty)=1$, ou seja, a resposta impulsiva do filtro
$H_0(z)$ satisfaz $h_0(0)=1$. \cite{campestrini}

\begin{figure}[htbp]
\center
% Generated with LaTeXDraw 2.0.8
% Wed Jun 20 23:11:16 BRT 2012
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-1.8192188)(9.851875,1.8192188)
\pscircle[linewidth=0.04,dimen=outer](1.431875,-0.79921883){0.2}
\psframe[linewidth=0.04,dimen=outer](4.431875,-0.3992188)(2.631875,-1.1992189)
\psframe[linewidth=0.04,dimen=outer](7.231875,-0.3992188)(5.631875,-1.1992189)
\pscircle[linewidth=0.04,dimen=outer](8.431875,-0.79921883){0.2}
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(0.031875,-0.79921883)(1.231875,-0.79921883)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(1.631875,-0.79921883)(2.631875,-0.79921883)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(4.431875,-0.79921883)(5.631875,-0.79921883)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(7.231875,-0.79921883)(8.231875,-0.79921883)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.43,0.39921868)(8.431875,-0.5992188)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.631875,-0.79921883)(9.831875,-0.79921883)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(1.431875,-0.99921876)(1.431875,-1.7992188)
\psline[linewidth=0.04cm](1.431875,-1.7992188)(9.231875,-1.7992188)
\psline[linewidth=0.04cm](9.231875,-1.7992188)(9.231875,-0.79921883)
\usefont{T1}{ptm}{m}{n}
\rput(1.0698436,-0.48921886){+}
\usefont{T1}{ptm}{m}{n}
\rput(8.069845,-0.48921886){+}
\usefont{T1}{ptm}{m}{n}
\rput(8.069845,-1.0892189){+}
\usefont{T1}{ptm}{m}{n}
\rput(1.6339064,-1.0892189){-}
\usefont{T1}{ptm}{m}{n}
\rput(0.441875,-0.49921885){\small $r(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(3.561875,-0.79921883){\small $C(z, \theta)$}
\usefont{T1}{ptm}{m}{n}
\rput(6.331875,-0.8192189){\small $G_0(z)$}
\usefont{T1}{ptm}{m}{n}
\rput(5.081875,-0.49921885){\small $u(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(1.941875,-0.49921885){\small $\varepsilon (t)$}
\usefont{T1}{ptm}{m}{n}
\rput(8.851875,0.12078118){\small $\nu(t)$}
\usefont{T1}{ptm}{m}{n}
\rput(9.271875,-0.49921885){\small $y(t)$}
\psframe[linewidth=0.04,dimen=outer](9.231875,1.2007811)(7.631875,0.40078118)
\usefont{T1}{ptm}{m}{n}
\rput(8.411875,0.7807812){\small $H_0(z)$}
\psline[linewidth=0.04cm](8.43,1.1992186)(8.43,1.7992188)
\usefont{T1}{ptm}{m}{n}
\rput(8.871875,1.5807811){\small $e(t)$}
\end{pspicture} 
}
\caption{Representação de um sistema de controle em malha fechada, com ruido aditivo na saída. São apresentados também
os prncipais sinais referênciados.}
\label{fig:vrft_db_control_loop}
\end{figure}

A equação: 

\begin{equation}
T(z, \theta)=\frac{C(z,\theta)G_0(z)}{1+C(z,\theta)G_0(z)}
\label{eq:vrft_db_closed_loop}
\end{equation}

descreve a relação entre entrada e saída do sistema apresentado na Figura (\ref{fig:vrft_db_control_loop}). Desta
forma pode se escrever o sinal de saída do sistema como:

\begin{equation}
y(t)=T(z, \theta)r(t)
\label{eq:dbcd_def_yr}
\end{equation}

O comportamento desejado para o sistema em malha fechada é definido por $T_d(z)$.

%===============================================================================
\subsection{Critérios de performance}
\label{sec:dbcd_performance_criteria}
%===============================================================================

Como já foi apresentado no capítulo sobre identificação de sistemas lineares (capítulo
\ref{chapter:system_identification}), existe um critério para elencar qual é o melhor conjunto de parametros $\theta$
pra a classe de modelos escolhida. Para isso, foi apresentado a equação \eqref{eq:si_obj_etim_lsm_v} como um dos
critérios mais utilizados. Para projeto de controladores existem desdobramentos deste critério em
função dos objetivos básicos de controle:

\begin{itemize}
  \item Seguimento de referência,
  \item Rejeição a ruído e 
  \item Uso reduzido de esforço de controle. 
\end{itemize}

Para o objetivo de seguimento de referência, a performance por este ponto de vista pode ser avaliada pela norma:
\cite{bazanella_datadriven}

\begin{equation}
J_y(\theta)\overset{\underset{\mathrm{\Delta}}{\,}}{=}  \bar{E} \left [ y(t)-y_d(t) \right ]^2 = \bar{E}\left [
(T(z,\theta)-T_d(z))r(t) \right ]^2
\label{eq:dbcd_def_track_error}
\end{equation}

Onde $y(t)$ é a saída medida do sistema e $y_d(t)$ é a saída desejada.

Com base nas equações \eqref{eq:dbcd_def_track_error} e \eqref{eq:vrft_db_closed_loop} é possível determinar o
equacionamento para o controlador ideal. Aquele que irá fazer com que o sistema em malha fechada se comporte como o
desejado.

\begin{equation}
C_d(z)=\frac{T_d(z)}{G_0(z)(1-T_d(z))}
\label{eq:dbcd_perf_tracking_cd}
\end{equation}

Outro objetivo fundamental é minimizar o efeito do ruído sobre a saída do sistema. Descreve-se a função sensibilidade
$S(z, \theta)$ como:

\begin{equation}
S(z, \theta)=\frac{1}{1+C(z, \theta)G_0(z)}
\label{eq:dbcd_perf_sensitiv}
\end{equation}

A saída do sistema em malha fechada referente apenas ao ruído, ou seja, sem levar em conta a parte relativa a referência
é dada por: \cite{bazanella_datadriven}

\begin{equation}
y_e(t, \theta) \overset{\underset{\mathrm{\Delta}}{\,}}{=} S(z, \theta)\nu(t)
\label{eq:dbcd_perf_ye}
\end{equation}

O critério que determina a performance do sistema na rejeição ao ruído é dado por:

\begin{equation}
J_e(\theta) \overset{\underset{\mathrm{\Delta}}{\,}}{=} \bar{E}\left [ y_e(t) \right ]^2 = \bar{E}\left [  S(z,
\theta)\nu(t) \right ]^2
\label{eq:dbcd_perf_je}
\end{equation}

Para fazer com que $J_e(\theta)=0$ seria necessário que $S(z,\theta)=0 \forall z$, o que demandaria que $C(z,
\theta)G_0(z) \to \infty \forall z$, tornando desta forma impossível de atingir o objetivo do critério ser zero.
Relaxa-se então o critério de performance para:   

\begin{equation}
J_e(\theta) \overset{\underset{\mathrm{\Delta}}{\,}}{=} \bar{E}\left [ (S(z, \theta)-S_d(z,\theta))\nu(t) \right ]^2 
\label{eq:dbcd_perf_je_relax}
\end{equation}

Onde $S_d(z,\theta)$ é a função sensibilidade desejada para o sistema.

Como $J_y(\theta)$ em \eqref{eq:dbcd_def_track_error} é o critério para minimização da saída do sistema e como
$J_e(\theta)$ é o critério para minimização do ruído sobre a saída, é simples compreender que $J_y(\theta)$ intégra  
$J_e(\theta)$, ou seja, minimizando $J_y(\theta)$ é o equivalente a também minimizar a parte relativa ao ruído.

Assim como o controlador apresentado em \eqref{eq:dbcd_perf_tracking_cd} é o controlador ótimo para o critério de
performance de seguimento de referência, para o critério de rejeição ao rúido o controlador ótimo pode ser obtido. Para
minimizar a função custo \eqref{eq:dbcd_perf_je} escolhe-se $T_e(z)$ como abaixo (Detalhes podem ser obtidos em
\cite{bazanella_datadriven})

\begin{equation}
T_e(z)= 1-\frac{1}{H(z)} 
\label{eq:dbcd_perf_te}
\end{equation}

Da onde obtem-se o controlador desejado para a rejeição ao ruído $C_e(z)$:

\begin{equation}
C_e(z)=\frac{T_e(z)}{G_0(z)(1-T_e(z))}=\frac{H(z)-1}{G_0(z)} 
\label{eq:dbcd_perf_ce}
\end{equation}

O controladore apresentado em \eqref{eq:dbcd_perf_ce} também é conhecido como controlador da minima variância.

Neste trabalho os exemplos utilizados usam-se o critério de seguimento de referência, com o controlador ótimo desejado
sendo representado por \eqref{eq:dbcd_perf_tracking_cd}.

%%===============================================================================
%\subsection{Iterative feedback tuning}
%\label{sec:dbcd_ift}
%%===============================================================================
%
%O método IFT utiliza um algoritmo iterativo para minimizar uma função custo $H_2$. O método
%considera que o sistema é controlado por um controlador com dois graus de liberdade:
%
%\begin{equation}
%u(t)=C_r(z)r(t)-C_y(z)y(t)
%\label{eq:vrft_db_ift_controller}
%\end{equation}
%
%Na Figura (\ref{fig:vrft_db_ift}) é apresentado a organização dos blocos dos controladores
%de \eqref{eq:vrft_db_ift_controller}, $C_r(z)$ e $C_y(z)$. O controlador pode ser
%entendido como o conjunto destes dois:\cite{Hjalmarsson_ift1998}
%
%\begin{equation}
%C(z) \equiv  \left \{ C_r(z),\, C_y(z)  \right \} 
%\nonumber
%\end{equation}
%
%\begin{figure}[htbp]
%\center
%\scalebox{1} % Change this value to rescale the drawing.
%{
%\begin{pspicture}(0,-1.68)(9.48,1.72)
%\usefont{T1}{ptm}{m}{n}
%\rput(7.691875,1.5215625){\small $\nu(t)$}
%\pscircle[linewidth=0.04,dimen=outer](4.0,0.32){0.2}
%\pscircle[linewidth=0.04,dimen=outer](8.0,0.32){0.2}
%\psframe[linewidth=0.04,dimen=outer](6.8,0.72)(5.2,-0.08)
%\psframe[linewidth=0.04,dimen=outer](2.8,0.72)(1.2,-0.08)
%\psframe[linewidth=0.04,dimen=outer](6.8,-0.88)(5.2,-1.68)
%\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(0.0,0.32)(1.2,0.32)
%\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(2.8,0.32)(3.8,0.32)
%\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(4.2,0.32)(5.2,0.32)
%\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(6.8,0.32)(7.8,0.32)
%\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.2,0.32)(9.2,0.32)
%\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(6.8,-1.28)(8.0,-1.28)
%\psline[linewidth=0.04cm](8.0,-1.28)(8.0,0.12)
%\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{<-}(4.0,0.12)(4.0,-1.28)
%\psline[linewidth=0.04cm](4.0,-1.28)(5.2,-1.28)
%\usefont{T1}{ptm}{m}{n}
%\rput(8.911875,0.5215625){\small $y(t)$}
%\usefont{T1}{ptm}{m}{n}
%\rput(0.481875,0.5215625){\small $r(t)$}
%\usefont{T1}{ptm}{m}{n}
%\rput(1.901875,0.3215625){\small $C_r(z)$}
%\usefont{T1}{ptm}{m}{n}
%\rput(5.951875,0.3215625){\small $G_0(z)$}
%\usefont{T1}{ptm}{m}{n}
%\rput(5.931875,-1.2784375){\small $C_y(z)$}
%\usefont{T1}{ptm}{m}{n}
%\rput(4.721875,0.7215625){\small $u(t)$}
%\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.0,1.32)(8.0,0.52)
%\usefont{T1}{ptm}{m}{n}
%\rput(4.2592187,0.1315625){-}
%\end{pspicture} 
%}
%\caption{Diagrama de bloco do sistema utilizado na identificação IFT.}
%\label{fig:vrft_db_ift}
%\end{figure}
%
%A função custo utilizada como critério no método é apresentada em \eqref{eq:vrft_db_ift_j_cost}. 
%
%\begin{equation}
%J(\theta)=\frac{1}{2N}E\left [ \sum_{t=1}^{N}(L_y \tilde{y}_t(\theta))^2 +\lambda  \sum_{t=1}^{N}(L_u
%u_t(\theta))^2 \right ]
%\label{eq:vrft_db_ift_j_cost}
%\end{equation}
%
%O primeiro termo em \eqref{eq:vrft_db_ift_j_cost} é o erro entre a resposta obtida e a resposta
%desejada, balanceada por um filtro $L_y$ a segunda parte é o custo de controle balanceado pelo
%filtro $L_u$. Com $T_0(\theta)$ e $S_0(\theta)$ sendo a função de transferência em malha fechada e a
%função sensibilidade, respectivamente:
%
%
%\begin{equation}
%T_0(\theta)=\frac{C_r(\theta)G_0}{1+C_y(\theta)G_0}
%\nonumber
%\end{equation}
%
%\begin{equation}
%S_0(\theta)=\frac{1}{1+C_y(\theta)G_0}
%\nonumber
%\end{equation}
%
%E sendo $r$ e $\nu(t)$ independentes, \eqref{eq:vrft_db_ift_j_cost} pode ser rescrito como
%\eqref{eq:vrft_db_ift_j_cost_parts}
%
%\begin{equation}
%J(\theta)=\frac{1}{2N}\sum_{t=1}^{N}\left \{ L_y(T_d r-T_0(\theta)r) \right \}^2+\frac{1}{2} E\left [ \left \{ L_y S_0(\theta) \nu(t) \right \}^2 \right ]
%+ \lambda \frac{1}{2N}E\left [ \sum_{t=1}^{N}(L_u u_t(\theta))^2 \right ]
%\label{eq:vrft_db_ift_j_cost_parts}
%\end{equation}
%
%Onde o primeiro termo é o erro de seguimento de referência, o segundo é a contribuição do distúrbio
%e o terceiro é o esforço de controle.
%
%Para minimizar \eqref{eq:vrft_db_ift_j_cost_parts}, busca-se encontrar um ponto
%estacionário da equação, para isso calcula-se o gradiente desta equação e aplica-se o
%algoritmo para a convergência apresentado em \eqref{eq:vrft_db_ift_algoritm}.
%\cite{hajalmson_ift_non_linear}
%
%\begin{equation}
%\theta_{i+1}=\theta_i - \gamma_i R_i^{-1}\frac{\partial J}{\partial \theta}(\theta_i)
%\label{eq:vrft_db_ift_algoritm}
%\end{equation}
%
%$R_i$ é uma matriz positiva definida, tipicamente uma estimativa da Hessiana de $J$, como por
%exemplo a aproximação de Gauss-Newton.
%
%Para cada iteração $i$ em \eqref{eq:vrft_db_ift_algoritm}, o método IFT necessita de dois
%experimentos, cada um de tamanho $N$. 
%
